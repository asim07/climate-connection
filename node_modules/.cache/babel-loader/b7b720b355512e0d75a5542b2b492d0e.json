{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n  Accept: \"application/json\",\n  \"Content-Type\": \"application/json\"\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n  headers: DEFAULT_HTTP_HEADERS,\n  method: DEFAULT_HTTP_METHOD\n};\nexport class HttpConnection {\n  constructor(url) {\n    this.url = url;\n    this.events = new EventEmitter();\n    this.isAvailable = false;\n    this.registering = false;\n\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n\n    this.url = url;\n  }\n\n  get connected() {\n    return this.isAvailable;\n  }\n\n  get connecting() {\n    return this.registering;\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async open() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n    await this.register(url);\n  }\n\n  async close() {\n    if (!this.isAvailable) {\n      throw new Error(\"Connection already closed\");\n    }\n\n    this.onClose();\n  }\n\n  async send(payload, context) {\n    if (!this.isAvailable) {\n      await this.register();\n    }\n\n    try {\n      const body = safeJsonStringify(payload);\n      const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n        body\n      }));\n      const data = await res.json();\n      this.onPayload({\n        data\n      });\n    } catch (e) {\n      this.onError(payload.id, e);\n    }\n  }\n\n  async register() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n\n    if (this.registering) {\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", error => {\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          if (typeof this.isAvailable === \"undefined\") {\n            return reject(new Error(\"HTTP connection is missing or invalid\"));\n          }\n\n          resolve();\n        });\n      });\n    }\n\n    this.url = url;\n    this.registering = true;\n\n    try {\n      const body = safeJsonStringify({\n        id: 1,\n        jsonrpc: \"2.0\",\n        method: \"test\",\n        params: []\n      });\n      await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n        body\n      }));\n      this.onOpen();\n    } catch (e) {\n      const error = this.parseError(e);\n      this.events.emit(\"register_error\", error);\n      this.onClose();\n      throw error;\n    }\n  }\n\n  onOpen() {\n    this.isAvailable = true;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n\n  onClose() {\n    this.isAvailable = false;\n    this.registering = false;\n    this.events.emit(\"close\");\n  }\n\n  onPayload(e) {\n    if (typeof e.data === \"undefined\") return;\n    const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n\n  onError(id, e) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n\n  parseError(e) {\n    let url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;\n    return parseConnectionError(e, url, \"HTTP\");\n  }\n\n}\nexport default HttpConnection;","map":{"version":3,"sources":["../../src/http.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError, } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\",\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n    headers: DEFAULT_HTTP_HEADERS,\n    method: DEFAULT_HTTP_METHOD,\n};\nexport class HttpConnection {\n    constructor(url) {\n        this.url = url;\n        this.events = new EventEmitter();\n        this.isAvailable = false;\n        this.registering = false;\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        this.url = url;\n    }\n    get connected() {\n        return this.isAvailable;\n    }\n    get connecting() {\n        return this.registering;\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async open(url = this.url) {\n        await this.register(url);\n    }\n    async close() {\n        if (!this.isAvailable) {\n            throw new Error(\"Connection already closed\");\n        }\n        this.onClose();\n    }\n    async send(payload, context) {\n        if (!this.isAvailable) {\n            await this.register();\n        }\n        try {\n            const body = safeJsonStringify(payload);\n            const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            const data = await res.json();\n            this.onPayload({ data });\n        }\n        catch (e) {\n            this.onError(payload.id, e);\n        }\n    }\n    async register(url = this.url) {\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        if (this.registering) {\n            return new Promise((resolve, reject) => {\n                this.events.once(\"register_error\", error => {\n                    reject(error);\n                });\n                this.events.once(\"open\", () => {\n                    if (typeof this.isAvailable === \"undefined\") {\n                        return reject(new Error(\"HTTP connection is missing or invalid\"));\n                    }\n                    resolve();\n                });\n            });\n        }\n        this.url = url;\n        this.registering = true;\n        try {\n            const body = safeJsonStringify({ id: 1, jsonrpc: \"2.0\", method: \"test\", params: [] });\n            await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            this.onOpen();\n        }\n        catch (e) {\n            const error = this.parseError(e);\n            this.events.emit(\"register_error\", error);\n            this.onClose();\n            throw error;\n        }\n    }\n    onOpen() {\n        this.isAvailable = true;\n        this.registering = false;\n        this.events.emit(\"open\");\n    }\n    onClose() {\n        this.isAvailable = false;\n        this.registering = false;\n        this.events.emit(\"close\");\n    }\n    onPayload(e) {\n        if (typeof e.data === \"undefined\")\n            return;\n        const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n        this.events.emit(\"payload\", payload);\n    }\n    onError(id, e) {\n        const error = this.parseError(e);\n        const message = error.message || error.toString();\n        const payload = formatJsonRpcError(id, message);\n        this.events.emit(\"payload\", payload);\n    }\n    parseError(e, url = this.url) {\n        return parseConnectionError(e, url, \"HTTP\");\n    }\n}\nexport default HttpConnection;\n//# sourceMappingURL=http.js.map"]},"metadata":{},"sourceType":"module"}